**Made by Nicol√≤ Baroncini (1834907)**
## Application (9_A_2)
**[Press here](https://drive.google.com/file/d/1gmHTK3R-mPtSlB7SOOl4bhKHuE2BEkoG/view?usp=sharing)** to download the zip that contains the application.

In the program are used 2 random variables and so two classes have been made to generate them and the related paths: \
**1-** RademacherRVGenerator \
**2-** NormalRVGenerator

Let's now see each of them in detail.
**RademacherRVGenerator**
Below there's the constructor where a Random object is instantiated.
{% highlight C# %}
public RademacherRVGenerator()
{
    r = new Random();
}
{% endhighlight %}

The random object is used to select the value that has to be returned in the GetValue function. The return value of this function is the value that has been generated with the Rademacher random variable.
{% highlight C# %}
int[] pv = {1, -1};
public int GetValue()
{
    return pv[r.Next(0,2)];
}
{% endhighlight %}

In the next function is computed the jump.
{% highlight C# %}
public double GetJump(double n)
{
    return Math.Sqrt(1 / n) * (double)GetValue();
}
{% endhighlight %}

The jump computed with GetJump function is then used to generates the random walk path. Each jump value is summed to the actual position of each path. The number of paths (m) and the number of jumps (n) is set in the windows form by the user.
{% highlight C# %}
public List<List<PointF>> GetJumpsPaths(int n, int m)
{
    List<List<PointF>> res = new List<List<PointF>>();

    for(int i = 0; i < m; i++)
    {
        List<PointF> path = new List<PointF>();
        double pos = 0;
        for(int j = 0; j < n; j++)
        {
            pos += GetJump(n);
            path.Add(new PointF(j, (float)pos));
        }
        res.Add(path);
    }

    return res;
}
{% endhighlight %}

**NormalRVGenerator**

{% highlight C# %}
public NormalRVGenerator()
{
    r = new Random();
}
{% endhighlight %}

{% highlight C# %}
public double GetStandardValue()
{
    double u1 = r.NextDouble();
    double u2 = r.NextDouble();
    return Math.Sqrt(-2 * Math.Log(u1))*Math.Cos(2*Math.PI*u2);
}                    
{% endhighlight %}

{% highlight C# %}
public List<List<PointF>> GetJumpsPaths(int n, int m)
{
    List<List<PointF>> res = new List<List<PointF>>();

    for (int i = 0; i < m; i++)
    {
        List<PointF> path = new List<PointF>();
        double pos = 0;
        for (int j = 0; j < n; j++)
        {
            pos += GetStandardValue();
            path.Add(new PointF(j, (float)pos));
        }
        res.Add(path);
    }

    return res;
}        
{% endhighlight %}

                             
<iframe src="https://user-images.githubusercontent.com/78324346/140970712-0d369001-0e5c-47e4-8b11-33cc7d1939a4.mp4" width="700" height="480" frameborder="0" allowfullscreen=""> </iframe>
