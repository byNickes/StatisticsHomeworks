**Made by Nicol√≤ Baroncini (1834907)**
## Application (10_A)
**[Press here](https://drive.google.com/file/d/1Gki5gAhYtRQ4GYqRyb5yN3zl6vyx1jQ6/view?usp=sharing)** to download the zip that contains the application.


**UniformRVGenerator**

{% highlight C# %}
public double GetValue()
{
    return Math.Round(r.NextDouble(),2);
}
{% endhighlight C# %}

**Main and other classes**
{% highlight C# %}
for(int i = 0; i < m; i++)
{
    double mean = 0;
    values.Add(new List<double>());
    for(int j = 0; j < n; j++)
    {
        double v = n_g.GetValue();
        values[i].Add(v);
        mean += (v - mean) / (j+1);
    }
    means.Add(mean);
}
{% endhighlight C# %}

{% highlight C# %}
//get first statistics
List<double> first_stat = new List<double>();
Dictionary<double, int> d_first = new Dictionary<double, int>();
for(int i = 0; i < m; i++)
{
    double add = values[i][0];
    for(int j = 0; j < n; j++)
    {
        if (values[i][j] < add) add = values[i][j];
    }
    first_stat.Add(add);
    if (d_first.Keys.Contains(add)) d_first[add]++;
    else d_first[add] = 1;
}
{% endhighlight C# %}
                               
{% highlight C# %}
//get last statistics
List<double> last_stat = new List<double>();
Dictionary<double, int> d_last = new Dictionary<double, int>();
for (int i = 0; i < m; i++)
{
    double add = -1;
    for (int j = 0; j < n; j++)
    {
        if (values[i][j] > add) add = values[i][j];
    }
    last_stat.Add(add);
    if (d_last.Keys.Contains(add)) d_last[add]++;
    else d_last[add] = 1;
}
{% endhighlight C# %}

{% highlight C# %}
List<double> k1 = d_first.Keys.ToList();
k1.Sort();
List<double> k2 = d_last.Keys.ToList();
k2.Sort();

List<PointF> p_first = new List<PointF>();
p_first.Add(new PointF(0, 0));
for(int i = 0; i < k1.Count; i++)
{
    p_first.Add(new PointF((float)k1[i], ((float)d_first[k1[i]] / ((float)m))));
}
p_first.Add(new PointF(p_first[k1.Count].X, 0));
p_first.Add(new PointF(1, 0));

List<PointF> p_last = new List<PointF>();
p_last.Add(new PointF(0, 0));
for (int i = 0; i < k2.Count; i++)
{
    if (i == 0) p_last.Add(new PointF((float)k2[i], 0));
    p_last.Add(new PointF((float)k2[i], ((float)d_last[k2[i]])/((float)m)));
}
p_last.Add(new PointF(1, 0));
{% endhighlight C# %}

**Comment**

The video of the application can be found below.
<iframe src="https://user-images.githubusercontent.com/78324346/142044653-ca6ea67b-5b9f-4d29-b7a9-2c91612cc2f0.mp4" width="700" height="480" frameborder="0" allowfullscreen=""> </iframe>
