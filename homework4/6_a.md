**Made by Nicol√≤ Baroncini (1834907)**
## Application (6_A)
**[Press here](https://drive.google.com/file/d/1ulPwevxZXO9NVJ5c3XfNs7Le1Hucw3pr/view?usp=sharing)** to download the zip that contains the application. \


### Part 1

{% highlight C# %}
//scatterplot for cy and mpg
scatter = new Scatterplot();
scatter.MaxX_Window = 50;
scatter.MaxY_Window = 50;
scatter.print_scatterplot(pictureBox1, dataset_mpg_cy, this, 5, 1);


//histogram for displacement
hist = new Histogram();
hist.MaxX_Window = 500;
hist.MaxY_Window = 500;
hist.print_histogram(pictureBox2, f_displacement, this, 20, dataset_displacement);

//compute frequencies for cy and mpg
Dictionary<((double, double), int), int> f_mpg_cy = new Dictionary<((double, double), int), int>();
insert_into_bivariate_distribution(f_mpg_cy, dataset_mpg_cy, 9, 12, 4);

//contingency table for cy and mpg
ct = new ContingencyTable();
ct.create_contingencytable(f_mpg_cy, "MPG", "Cylinders");
ct.print_contingencytable(pictureBox1.Width/2, pictureBox1.Height / 2, 16, pictureBox3, this);
{% endhighlight %}

{% highlight C# %}
private void timer1_Tick(object sender, EventArgs e)
{
    if(scatter != null && scatter.ready) scatter.DrawScene();
    if (hist != null && hist.ready) hist.DrawScene();
    if (ct != null && ct.ready) ct.DrawScene();
}
{% endhighlight %}

CONTIGENCY
{% highlight C# %}
//get highest width
List<((double, double), int)> f_var1_keys = frequencies.Keys.ToList();
for (int i = 0; i < frequencies.Count; i++)
{
    SizeF size_font = g.MeasureString(f_var1_keys[i].ToString(), new Font("Courier New", char_size));
    single_height = (int)size_font.Height;
    int length_temp = (int)size_font.Width;
    if (length_temp > single_width) { 
        single_width = length_temp;
        longest_string = f_var1_keys[i].ToString();
    }
}
{% endhighlight %}

{% highlight C# %}
//draw column lines
List<((double, double), int)> f_var_keys = frequencies.Keys.ToList();
for (int i = 1; i < column_distinct_keys.Count+1; i++)
{
    g.DrawLine(line, new Point(X_Viewport(0), Y_Viewport(height_tot - single_height*i)), new Point(X_Viewport(width_tot), Y_Viewport(height_tot - single_height*i)));
}

//draw row lines
for (int i = 1; i < row_distinct_keys.Count + 1; i++)
{
    g.DrawLine(line, new Point(X_Viewport(i * single_width), Y_Viewport(0)), new Point(X_Viewport(i * single_width), Y_Viewport(height_tot)));
}
{% endhighlight %}


{% highlight C# %}
//draw keys of row variable
for(int i = 1; i <= row_distinct_keys.Count; i++)
{
    (double, double) t = row_distinct_keys[i - 1];
    g.DrawString(t.ToString(), new Font("Courier New", char_size), brush, new Point(X_Viewport(i * single_width), Y_Viewport(height_tot)));
}

//draw keys of column variable
for (int i = 1; i <= column_distinct_keys.Count; i++)
{
    int t = column_distinct_keys[i - 1];
    g.DrawString(t.ToString(), new Font("Courier New", char_size), brush, new Point(X_Viewport(0), Y_Viewport((height_tot-single_height*i))));
}
{% endhighlight %}


{% highlight C# %}
//draw values
for(int i = 0; i < column_distinct_keys.Count; i++)
{
    for(int j = 0; j < row_distinct_keys.Count; j++)
    {
        int to_print;
        if (frequencies.Keys.Contains((row_distinct_keys[j], column_distinct_keys[i])))
        {
            to_print = frequencies[(row_distinct_keys[j], column_distinct_keys[i])];
            g.DrawString(to_print.ToString(), new Font("Courier New", char_size), brush, new Point(X_Viewport(single_width * (j+1)), Y_Viewport((height_tot - single_height * (i+1)))));
        }
        else g.DrawString(0.ToString(), new Font("Courier New", char_size), brush, new Point(X_Viewport(single_width * (j+1)), Y_Viewport((height_tot - single_height * (i+1)))));
    }
}
{% endhighlight %}

{% highlight C# %}
void pictureBox_Wheel(object sender, MouseEventArgs e)
{
    SizeF size_font = g.MeasureString(longest_string, new Font("Courier New", char_size));
    if (size_font.Width >= X_Viewport(single_width) - X_Viewport(0))
    {
        char_size -= 1;
    }
    else if (size_font.Width < X_Viewport(single_width) - X_Viewport(0))
    {
        while (size_font.Width < X_Viewport(single_width) - X_Viewport(0))
        {
            char_size += 1;
            size_font = g.MeasureString(longest_string, new Font("Courier New", char_size));
        }
        char_size -= 1;
    }
}
{% endhighlight %}

SCATTER

{% highlight C# %}
public void DrawScene()
{
    g.Clear(pb.BackColor);

    for (int i = 0; i < data.Count; i++)
    {
        g.FillEllipse(Brushes.Black, new Rectangle(new Point(X_Viewport(data[i].Item1) - 3, Y_Viewport(data[i].Item2) - 3), new Size(6, 6)));
    }

    Pen p = new Pen(Color.Red, 2);
    g.DrawRectangle(p, mv_r.r);

    pb.Image = b;
}
{% endhighlight %}

HISTOGRAM

{% highlight C# %}
public void DrawScene()
{
    g.Clear(pb.BackColor);
    Pen p2 = new Pen(Color.Orange);

    List<(double, double)> keys = data.Keys.ToList();
    for (int i = 0; i < keys.Count; i++)
    {
        //draw single rectangles of the histogram
        Rectangle h_mv = h_mv_l[keys[i]];
        h_mv.X = X_Viewport(keys[i].Item1);
        h_mv.Y = Y_Viewport(data[keys[i]]);
        //h_mv.Y = Y_Viewport(0); to flip histogram
        h_mv.Height = mv_r.r.Height - (Y_Viewport(data[keys[i]]) - mv_r.r.Y);
        h_mv.Width = X_Viewport(keys[i].Item2) - X_Viewport(keys[i].Item1);

        g.FillRectangle(Brushes.Green, h_mv);

        //draw mean line
        g.DrawLine(p2, new Point(X_Viewport(mean[keys[i]].Item1), mv_r.r.Y+mv_r.r.Height), new Point(X_Viewport(mean[keys[i]].Item1), Y_Viewport(data[keys[i]]+30)));
    }

    Pen p = new Pen(Color.Black, 2);
    g.DrawRectangle(p, mv_r.r);

    pb.Image = b;
}
{% endhighlight %}

<iframe src="https://user-images.githubusercontent.com/78324346/138348045-40511749-f795-4cf5-89f9-887947024897.mp4" width="700" height="480" frameborder="0" allowfullscreen=""> </iframe>

### Part 2

{% highlight C# %}
public void DrawScene(bool no_clear)
{
    if(!no_clear) g.Clear(pb.BackColor);
    Pen p2 = new Pen(Color.Orange);

    List<(double, double)> keys = data.Keys.ToList();
    Pen p3 = new Pen(Color.Black, 3);
    Pen p4 = new Pen(Color.Purple, 2);
    if (!draw_y)
    {
        for (int i = 0; i < keys.Count; i++)
        {
            //draw single rectangles of the histogram
            Rectangle h_mv = h_mv_l[keys[i]];
            h_mv.X = X_Viewport(keys[i].Item1);
            //h_mv.Y = Y_Viewport(data[keys[i]]);
            h_mv.Y = Y_Viewport(0); //to flip histogram
            h_mv.Height = mv_r.r.Height - (Y_Viewport(data[keys[i]]) - mv_r.r.Y);
            h_mv.Width = X_Viewport(keys[i].Item2) - X_Viewport(keys[i].Item1);

            g.FillRectangle(Brushes.Green, h_mv);
            g.DrawRectangle(p3, h_mv);

            //draw mean line
            if (data[keys[i]] != 0) g.DrawLine(p2, new Point(X_Viewport(mean[keys[i]].Item1), Y_Viewport(0)), new Point(X_Viewport(mean[keys[i]].Item1), Y_Viewport(-(data[keys[i]] + 30))));
        }

        for(int i = 0; i < dataset_displacement.Count; i++)
        {
            g.DrawLine(p4, new Point(X_Viewport(dataset_displacement[i]), Y_Viewport(-0.5)), new Point(X_Viewport(dataset_displacement[i]), Y_Viewport(0.5)));
        }
    }
    else
    {
        for (int i = 0; i < keys.Count; i++)
        {
            //draw single rectangles of the histogram
            Rectangle h_mv = h_mv_l[keys[i]];
            h_mv.Y = Y_Viewport(keys[i].Item2);
            //h_mv.Y = Y_Viewport(data[keys[i]]);
            h_mv.Width = X_Viewport(data[keys[i]]) - mv_r.r.X;
            h_mv.Height = Math.Abs(Y_Viewport(keys[i].Item2) - Y_Viewport(keys[i].Item1));
            h_mv.X = X_Viewport(-data[keys[i]]);

            g.FillRectangle(Brushes.Green, h_mv);
            g.DrawRectangle(p3, h_mv);

            //draw mean line
            if (data[keys[i]] != 0) g.DrawLine(p2, new Point(X_Viewport(0), Y_Viewport(mean[keys[i]].Item1)), new Point(X_Viewport(-(data[keys[i]] + 30)), Y_Viewport(mean[keys[i]].Item1)));
        }

        for (int i = 0; i < dataset_displacement.Count; i++)
        {
            g.DrawLine(p4, new Point(X_Viewport(-0.5), Y_Viewport(dataset_displacement[i])), new Point(X_Viewport(0.5), Y_Viewport(dataset_displacement[i])));
        }

    }



    Pen p = new Pen(Color.Black, 2);
    g.DrawRectangle(p, mv_r.r);

    pb.Image = b;
}
{% endhighlight %}

<iframe src="https://user-images.githubusercontent.com/78324346/138348051-a80620a2-cefa-4b67-82f3-ddf1278e2e6c.mp4" width="700" height="480" frameborder="0" allowfullscreen=""> </iframe>




