**Made by Nicol√≤ Baroncini (1834907)**
## Application (8_A)
**[Press here](https://drive.google.com/file/d/15dEhLHyXJY7xjbqwW7VIP4A2DPjHwRD0/view?usp=sharing)** to download the zip that contains the application. \
The application is divided in mostly 2 parts: \
**1-** BernoulliRVGenerator \
**2-** LinePlotter \

The BernoulliRVGenerator class has the job of generating Bernoulli random variables. Using their value it creates paths using relative frequencies, normalized relative frequencies or absolute frequencies. A path is a list of points where for each the x coordinate is the number of the bernoulli trial and the y coordinate is the frequency of success until trial x.

The LinePlotter class draws both the paths generated by BernoulliRVGenerator class on the picture box and two histograms on the chart that show how many points of each paths are into an interval. The leftmost histogram shows how many points of each paths are into an interval until a point j set by the user. Instead, the rightmost histogram shows how many points of each paths are into an interval after the last bernoulli trial.

Let's see now separately the two parts.

### BernoulliRVGenerator
**AA**
{% highlight C# %}
private int bernoulli_trial(double p)
{
    double random_outcome = r.NextDouble();

    if (random_outcome <= p) return 1;
    else return 0;
}
{% endhighlight %}
**AA**
{% highlight C# %}
private List<int> ListofTrials()
{
    List<int> bernoullis = new List<int>();

    for (int i = 0; i < n; i++)
    {
        bernoullis.Add(bernoulli_trial(p));
    }

    return bernoullis;
}
{% endhighlight %}
**AA**
{% highlight C# %}
private List<PointF> createRFPath(List<int> trials)
{
    float mean = 0;
    float num = 0;
    List<PointF> path = new List<PointF>();

    for(int i = 0; i < n; i++)
    {
        num++;
        mean = mean + (trials[i] - mean) / num;
        path.Add(new PointF(i, mean));
    }
    return path;
}
                         
public List<List<PointF>> createRFPaths(int m_in, int n_in, double p_in)
{
    List<List<PointF>> paths = new List<List<PointF>>();
    m = m_in;
    n = n_in;
    p = p_in;
    for (int i = 0; i < m; i++)
    {
        paths.Add(createRFPath(ListofTrials()));
    }
    return paths;
}
{% endhighlight %}
**AA**           
{% highlight C# %}
private List<PointF> createNRFPath(List<int> trials)
{
    float mean = 0;
    float num = 0;
    List<PointF> path = new List<PointF>();

    for (int i = 0; i < n; i++)
    {
        num++;
        mean = (float)(mean + (trials[i] - mean) / num);
        double to_insert = mean / (float)(Math.Sqrt(p * (1 - p) / num));
        path.Add(new PointF(i, (float)to_insert));
    }
    return path;
}
                          
public List<List<PointF>> createNRFPaths(int m_in, int n_in, double p_in)
{
  List<List<PointF>> paths = new List<List<PointF>>();
  m = m_in;
  n = n_in;
  p = p_in;
  for (int i = 0; i < m; i++)
  {
    paths.Add(createNRFPath(ListofTrials()));
  }
  return paths;
}
{% endhighlight %}  
**AA**                 
{% highlight C# %}
private List<PointF> createAFPath(List<int> trials)
{
    float successes = 0;
    List<PointF> path = new List<PointF>();

    for (int i = 0; i < n; i++)
    {
        successes += trials[i];
        path.Add(new PointF(i, successes));
    }
    return path;
}
                          
public List<List<PointF>> createAFPaths(int m_in, int n_in, double p_in)
{
    List<List<PointF>> paths = new List<List<PointF>>();
    m = m_in;
    n = n_in;
    p = p_in;
    for (int i = 0; i < m; i++)
    {
        paths.Add(createAFPath(ListofTrials()));
    }
    return paths;
}
{% endhighlight %}
                          
### LinePlotter
{% highlight C# %}

{% endhighlight %}


The video of the whole application can be found below.
<iframe src="https://user-images.githubusercontent.com/78324346/139588920-bbe4b51b-2349-48f7-b6a2-6009ddd10e84.mp4" width="700" height="480" frameborder="0" allowfullscreen=""> </iframe>



