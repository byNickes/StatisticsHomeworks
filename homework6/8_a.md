**Made by Nicol√≤ Baroncini (1834907)**
## Application (8_A)
**[Press here](https://drive.google.com/file/d/15dEhLHyXJY7xjbqwW7VIP4A2DPjHwRD0/view?usp=sharing)** to download the zip that contains the application. \
The application is divided in mostly 2 parts: \
**1-** BernoulliRVGenerator \
**2-** LinePlotter

The BernoulliRVGenerator class has the job of generating Bernoulli random variables. Using their value it creates paths using relative frequencies, normalized relative frequencies or absolute frequencies. A path is a list of points where for each the x coordinate is the number of the bernoulli trial and the y coordinate is the frequency of success until trial x.

The LinePlotter class draws both the paths generated by BernoulliRVGenerator class on the picture box and two histograms on the chart that show how many points of each paths are into an interval. The leftmost histogram shows how many points of each paths are into an interval until a point j set by the user. Instead, the rightmost histogram shows how many points of each paths are into an interval after the last bernoulli trial. \
The charts that are drawn are dynamic so it's possible to change them zoom scale and to move them on the picture box.

Let's see now separately the two parts.

### BernoulliRVGenerator
The next function computes an outcome for the Bernoulli random variable by using an uniform distribution between 0 and 1.
{% highlight C# %}
private int bernoulli_trial(double p)
{
    double random_outcome = r.NextDouble();

    if (random_outcome <= p) return 1;
    else return 0;
}
{% endhighlight %}
This function uses the value get from bernoulli_trial function and puts it in a list of trials. This is done n times where n is the number of trials the user requested.
{% highlight C# %}
private List<int> ListofTrials()
{
    List<int> bernoullis = new List<int>();

    for (int i = 0; i < n; i++)
    {
        bernoullis.Add(bernoulli_trial(p));
    }

    return bernoullis;
}
{% endhighlight %}
The createRFPath function computes a list of points where the y coordinate is the mean of the Bernoulli random variable at trial n. The mean is equal to the relative frequency of successes in the case of this random variable.\
The function createRFPaths puts together each path, computed in the fuction just explained, in a list and returns it.
{% highlight C# %}
private List<PointF> createRFPath(List<int> trials)
{
    float mean = 0;
    float num = 0;
    List<PointF> path = new List<PointF>();

    for(int i = 0; i < n; i++)
    {
        num++;
        mean = mean + (trials[i] - mean) / num;
        path.Add(new PointF(i, mean));
    }
    return path;
}
                         
public List<List<PointF>> createRFPaths(int m_in, int n_in, double p_in)
{
    List<List<PointF>> paths = new List<List<PointF>>();
    m = m_in;
    n = n_in;
    p = p_in;
    for (int i = 0; i < m; i++)
    {
        paths.Add(createRFPath(ListofTrials()));
    }
    return paths;
}
{% endhighlight %}
The function createNRFPath does the same thing of the createRFPath function but the y coordinate is the normalized relative frequency of successes instead of the simple relative frequency. Also the createNRFPaths function is equal to the one seen before.
{% highlight C# %}
private List<PointF> createNRFPath(List<int> trials)
{
    float mean = 0;
    float num = 0;
    List<PointF> path = new List<PointF>();

    for (int i = 0; i < n; i++)
    {
        num++;
        mean = (float)(mean + (trials[i] - mean) / num);
        double to_insert = mean / (float)(Math.Sqrt(p * (1 - p) / num));
        path.Add(new PointF(i, (float)to_insert));
    }
    return path;
}
                          
public List<List<PointF>> createNRFPaths(int m_in, int n_in, double p_in)
{
  List<List<PointF>> paths = new List<List<PointF>>();
  m = m_in;
  n = n_in;
  p = p_in;
  for (int i = 0; i < m; i++)
  {
    paths.Add(createNRFPath(ListofTrials()));
  }
  return paths;
}
{% endhighlight %}  
The function createAFPath does the same thing of the createRFPath function but the y coordinate is the absolute frequency of successes instead of the simple mean. Also the createNRFPaths function is equal to the one seen before.               
{% highlight C# %}
private List<PointF> createAFPath(List<int> trials)
{
    float successes = 0;
    List<PointF> path = new List<PointF>();

    for (int i = 0; i < n; i++)
    {
        successes += trials[i];
        path.Add(new PointF(i, successes));
    }
    return path;
}
                          
public List<List<PointF>> createAFPaths(int m_in, int n_in, double p_in)
{
    List<List<PointF>> paths = new List<List<PointF>>();
    m = m_in;
    n = n_in;
    p = p_in;
    for (int i = 0; i < m; i++)
    {
        paths.Add(createAFPath(ListofTrials()));
    }
    return paths;
}
{% endhighlight %}
                          
### LinePlotter
The function print_paths prints the paths generated by the BernoulliRVGenerator.\
To understand what each part of the code does, the comments on the code can be read. \
In this case the histograms for normalized relative frequencies (which_path = 1) and for absolute frequencies (which_path = 2) are not drawn but so can be done just by decommenting the two lines in each if block at the end of the next code.
{% highlight C# %}
List<Color> colors;
List<PointF> temp_list;
public void print_paths(List<List<PointF>> paths, double e, double p, int j, bool keep_colors, int which_path)
{
    if (!keep_colors) colors = new List<Color>();
    g.Clear(pb.BackColor);

    //set windows values depending on what frequency needs to be drawn
    if (which_path == 0)
    {
        MinX_Window = 0;
        MaxX_Window = paths[0].Count; //n samples
        MaxY_Window = 1; //relative freq. is at maximum 1
        MinY_Window = 0;

        RangeX = MaxX_Window - MinX_Window;
        RangeY = MaxY_Window - MinY_Window;
    }
    else if (which_path == 1 || which_path == 2)
    {
        double max_freq = 0;
        //compute max value of frequency to draw
        for(int i = 0; i < paths[0].Count; i++)
        {
            if (paths[0][i].Y > max_freq) max_freq = paths[0][i].Y;
        }

        MinX_Window = 0;
        MaxX_Window = paths[0].Count;
        MaxY_Window = (int)max_freq+1;
        MinY_Window = 0;

        RangeX = MaxX_Window - MinX_Window;
        RangeY = MaxY_Window - MinY_Window;
    }

    Random rnd = new Random();
    for (int i = 0; i < paths.Count; i++)
    {
        if (paths != paths_old)
        {
            temp_list = new List<PointF>();
            //convert frequencies into points
            for (int l = 0; l < paths[i].Count; l++)
            {
                temp_list.Add(new PointF((float)X_Viewport(paths[i][l].X), (float)Y_Viewport(paths[i][l].Y)));
            }
        }
        //choose a random color for each path
        if (!keep_colors) { 
            Color randomColor = Color.FromArgb(rnd.Next(256), rnd.Next(256), rnd.Next(256));
            colors.Add(randomColor); 
        }
        Pen p_lines = new Pen(colors[i], 2);
        g.DrawLines(p_lines, temp_list.ToArray()); //draw all the lines that connect points of a path
    }

    //if path is of rel. freq. draw the neighbourhood lines
    if (which_path == 0)
    {
        Pen p_epsilon = new Pen(Color.Red, 1);
        g.DrawLine(p_epsilon, new PointF(mv_r.r.X, (float)Y_Viewport(p + e)), new PointF(mv_r.r.X + mv_r.r.Width, (float)Y_Viewport(p + e)));
        g.DrawLine(p_epsilon, new PointF(mv_r.r.X, (float)Y_Viewport(p - e)), new PointF(mv_r.r.X + mv_r.r.Width, (float)Y_Viewport(p - e)));
        g.DrawLine(p_epsilon, new PointF(mv_r.r.X, (float)Y_Viewport(p)), new PointF(mv_r.r.X + mv_r.r.Width, (float)Y_Viewport(p)));
    }
    Pen p_rec = new Pen(Color.Black, 5);
    g.DrawRectangle(p_rec, mv_r.r);

    //print histograms
    if (which_path == 0)
    {
        print_histogram(intervals_relative, paths, j);
        print_lasthistogram(intervals_relative, paths);
    }
    if (which_path == 1)
    {
        //print_histogram(intervals_normalizedrelative, paths, j);
        //print_lasthistogram(intervals_normalizedrelative, paths);
    }
    if (which_path == 2)
    {
        //print_histogram(intervals_absolute, paths, j);
        //print_lasthistogram(intervals_absolute, paths);
    }

    pb.Image = b;
}

{% endhighlight %}
The next function draws the histogram in the position j set by the user. \
To understand what each part of the code does, the comments on the code can be read.
{% highlight C# %}
public void print_histogram(double interval, List<List<PointF>> paths, int j)
{
    //if new path, compute new distribution of frequencies
    if (paths != paths_old)
    {
        List<List<double>> data_list = new List<List<double>>();
        distr_of_rfreq = new Dictionary<(double, double), int>();

        for (int i = 0; i < paths.Count; i++)
        {
            data_list.Add(new List<double>());
            for (int l = 0; l < paths[i].Count; l++)
            {
                if (paths[i][l].X <= j) data_list[i].Add(paths[i][l].Y);
            }
            insert_into_continuous_distribution(distr_of_rfreq, data_list[i], interval, 0, interval);
        }
    }

    List<(double, double)> keys = distr_of_rfreq.Keys.ToList();

    Pen p2 = new Pen(Color.Orange);
    Pen p3 = new Pen(Color.Black, 3);
    Pen p4 = new Pen(Color.Purple, 2);

    double scale = 1;
    int max_freq = 0;
    //find maximum frequency and adapt the scale of the histogram to it
    for(int i = 0; i < keys.Count; i++)
    {
        if (distr_of_rfreq[keys[i]] > max_freq) max_freq = distr_of_rfreq[keys[i]];

        while (X_Viewport(max_freq/scale + j) > mv_r.r.Width+mv_r.r.X)
        {
            scale *= 2;
        } 
    }
    h_scale = scale;

    for (int i = 0; i < keys.Count; i++)
    {
        if (keys[i].Item2 > MaxY_Window) continue;

        //draw single rectangles of the histogram, one rectangle for each interval of the distribution
        Rectangle h_mv = new Rectangle(0,0,0,0);
        h_mv.Y = (int)Y_Viewport(keys[i].Item2);
        h_mv.Width = (int)X_Viewport(distr_of_rfreq[keys[i]]/scale) - mv_r.r.X;
        h_mv.Height = Math.Abs((int)Y_Viewport(keys[i].Item2) - (int)Y_Viewport(keys[i].Item1));
        h_mv.X = (int)X_Viewport(j);

        g.FillRectangle(Brushes.Green, h_mv);
        g.DrawRectangle(p3, h_mv);
    }

}
{% endhighlight %}
The next function draws the histogram after the last Bernoulli trial. \
To understand what each part of the code does, the comments on the code can be read.
{% highlight C# %}
Dictionary<(double, double), int> distr_of_rfreq_last;
public void print_lasthistogram(double interval, List<List<PointF>> paths)
{
    //if new path, compute new distribution of frequencies
    if (paths != paths_old)
    {
        List<List<double>> data_list = new List<List<double>>();
        distr_of_rfreq_last = new Dictionary<(double, double), int>();

        for (int i = 0; i < paths.Count; i++)
        {
            data_list.Add(new List<double>());
            for (int l = 0; l < paths[i].Count; l++)
            {
                data_list[i].Add(paths[i][l].Y);
            }
            insert_into_continuous_distribution(distr_of_rfreq_last, data_list[i], interval, 0, interval);
        }
    }

    List<(double, double)> keys = distr_of_rfreq_last.Keys.ToList();

    Pen p2 = new Pen(Color.Orange);
    Pen p3 = new Pen(Color.Black, 3);
    Pen p4 = new Pen(Color.Purple, 2);

    double scale = 1;
    int max_freq = 0;
    
    //find maximum frequency and adapt the scale of the histogram to it
    for (int i = 0; i < keys.Count; i++)
    {
        if (distr_of_rfreq_last[keys[i]] > max_freq) max_freq = distr_of_rfreq_last[keys[i]];

        while (mv_r.r.X + mv_r.r.Width + (int)X_Viewport(distr_of_rfreq_last[keys[i]] / scale) - mv_r.r.X > pb.Width && mv_r.r.X + mv_r.r.Width < pb.Width)
        {
            scale *= 2;
        }
    }
    lasth_scale = scale;
   
    for (int i = 0; i < keys.Count; i++)
    {
        if (keys[i].Item2 > MaxY_Window) continue;

        //draw single rectangles of the histogram, one rectangle for each interval of the distribution
        Rectangle h_mv = new Rectangle(0, 0, 0, 0);
        h_mv.Y = (int)Y_Viewport(keys[i].Item2);
        h_mv.Width = (int)X_Viewport(distr_of_rfreq_last[keys[i]] / scale) - mv_r.r.X;
        h_mv.Height = Math.Abs((int)Y_Viewport(keys[i].Item2) - (int)Y_Viewport(keys[i].Item1));
        h_mv.X = mv_r.r.X + mv_r.r.Width;

        g.FillRectangle(Brushes.Green, h_mv);
        g.DrawRectangle(p3, h_mv);
    }


    Pen p = new Pen(Color.Black, 2);
}
{% endhighlight %}


The video of the whole application can be found below.
<iframe src="https://user-images.githubusercontent.com/78324346/139588920-bbe4b51b-2349-48f7-b6a2-6009ddd10e84.mp4" width="700" height="480" frameborder="0" allowfullscreen=""> </iframe>

### Comment briefly on the convergence results you see.
In the first image are represented the relative frequencies computed by repeating Bernoulli trials until time n. In this case is possible to see that there is a convergence in probability to the expected value of the Bernoulli random variable from which are taken the trials results. For a Bernoulli random variable the expected value is equal to the probability of success.\
    It is an empirical proof of the weak law of large numbers.
![image](https://user-images.githubusercontent.com/78324346/139922505-667765b4-4a73-48e8-9983-f4405b2fea5e.png)

In the next two images are represented the normalized relative frequencies computed taking the relative frequency f(t) at time t and dividing it by sqrt(p(1-p)/t) where p is the probability of success. In this case higher is the probability of success, lower is the dispersion of the normalized relative frequency values. This means that if more is the probability of having a success then more different paths have the same number of successes at each istant and so the variability of the result of each trial is less then with a lower value of p.\
The first of the two images has a probability p equal to 0,75 while the second one has a probability p equal to 0,15.
![image](https://user-images.githubusercontent.com/78324346/139922597-64c7b38e-f83f-4f2e-8bb8-53724aa56438.png)
![image](https://user-images.githubusercontent.com/78324346/139926898-41322e67-59a6-4453-a882-c0b94c059fe0.png)

    
![image](https://user-images.githubusercontent.com/78324346/139922656-4e70df3f-5edf-41af-9fd5-2abc5cb4f85b.png)
